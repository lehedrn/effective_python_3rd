# Chapter 3: Loops and Iterators (循环和迭代器)

## Item 18: Use zip to Process Iterators in Parallel (使用 zip 并行处理迭代器)

Often in Python you find yourself with many lists of related objects. List comprehensions make it easy to take a source `list` and produce another derived `list` by applying an expression to each item (see Item 40: “Use Comprehensions Instead of map and filter ”). For example, here I take a list of names and create a corresponding list of how many characters are in each name:

在 Python 中，你经常会遇到多个相关对象列表的情况。列表推导式使得从源 `list` 创建另一个派生的 `list` 变得简单，只需对每个元素应用一个表达式即可（参见条目 40）。例如，这里我取一个名字列表，并创建一个对应的列表来表示每个名字中有多少个字符：

```
names = ["Cecilia", "Lise", "Marie"]
counts = [len(n) for n in names]
print(counts)
>>>
[7, 4, 5]
```

The items in the derived list ( `counts` ) are related to the items in the source list ( `names` ) by their corresponding positions in the sequences. To access items from both lists in a single loop, I can iterate over the length of the source list ( `names` ) and use the offsets generated by `range` to index into either list. For example, here I use parallel indexing to determine which name is the longest:

派生列表 (`counts`) 中的项与其源列表 (`names`) 中的项通过它们在序列中的相应位置相关联。要在单个循环中访问两个列表中的项目，可以遍历源列表 (`names`) 的长度，并使用由 `range` 生成的偏移量索引到任一列表中。例如，这里我使用并行索引来确定哪个名字最长：

```
longest_name = None
max_count = 0

for i in range(len(names)):
    count = counts[i]
    if count > max_count:
        longest_name = names[i]
        max_count = count

print(longest_name)

>>>
Cecilia
```

The problem is that this whole `for` statement is visually noisy. The indexing operations— `names[i]` and `counts[i]` —make the code hard to read. Indexing into two arrays by the same loop index i seems redundant. I can use the `enumerate` built-in function (see Item 17: “Prefer enumerate Over range ”) to improve this slightly, but it’s still not ideal because of the `counts[i]` indexing operation:

问题是这个整个 `for` 语句在视觉上显得杂乱。索引操作——`names[i]` 和 `counts[i]`——使代码难以阅读。通过相同的循环索引 `i` 索引到两个数组似乎有些冗余。我可以使用内置函数 `enumerate`（参见条目 17）稍微改进这一点，但因为还有 `counts[i]` 这样的索引操作，所以仍然不够理想：

```
longest_name = None
max_count = 0

for i, name in enumerate(names):  # Changed
    count = counts[i]
    if count > max_count:
        longest_name = name       # Changed
        max_count = count
assert longest_name == "Cecilia"
```

To make this code clearer, Python provides the `zip` built-in function. `zip` wraps two or more iterators with a lazy generator. The `zip` generator yields tuples containing the next value from each iterator. These tuples can be unpacked directly within a `for` statement (see Item 5: “Prefer Multiple Assignment Unpacking Over Indexing” for background). By eliminating indexing operations, the resulting code is much cleaner than the code above that separately accesses two lists:

为了使这段代码更清晰，Python 提供了 `zip` 内置函数。`zip` 将两个或更多迭代器包裹在一个惰性生成器中。该 `zip` 生成器会产出包含来自每个迭代器的下一个值的元组。这些元组可以在 `for` 语句中直接解包（参见条目 5）。通过消除索引操作，结果代码比上面分别访问两个列表的代码要干净得多：

```
longest_name = None
max_count = 0

for name, count in zip(names, counts):  # Changed
    if count > max_count:
        longest_name = name
        max_count = count
assert longest_name == "Cecilia"
```

`zip` consumes the iterators it wraps one item at a time, which means it can be used with infinitely long inputs without risk of your program using too much memory and crashing (see Item 43: “Consider Generators Instead of Returning Lists” and Item 44: “Consider Generator Expressions for Large List Comprehensions” for how to create such inputs).

`zip` 每次消耗它所包装的一个项目，这意味着它可以用于无限长的输入而无需担心程序占用太多内存而导致崩溃（关于如何创建这样的输入，请参见条目 43和条目）。

However, it’s important to beware of `zip` ’s behavior when the input iterators have different lengths. For example, say that I add another item to the `names` list, but I forget to update the `counts` list. Running `zip` on the two input lists has an unexpected result:

然而，当输入的迭代器长度不同时，需要注意 `zip` 的行为。例如，假设我在 `names` 列表中添加了一个新项，但我忘记更新 `counts` 列表。在这种情况下对这两个输入列表运行 zip 会产生意外的结果：

```
names.append("Rosalind")
for name, count in zip(names, counts):
    print(name)
>>>
Cecilia
Lise
Marie
```

The new item for `"Rosalind"` isn’t in the output. Why not? This is just how `zip` works. It keeps yielding tuples until any one of the wrapped iterators is exhausted. Its output is only as long as its shortest input. If premature truncation could be a problem for your program, you can pass the `strict` keyword argument to `zip` —a new option since Python 3.10—which will cause the returned generator to raise an exception if any of the inputs is exhausted before the others.

新的 "Rosalind" 项不在输出中。为什么？这正是 `zip` 的工作方式。它会持续产出元组直到被包裹的任意一个迭代器耗尽。它的输出长度仅与最短的输入一样长。如果提前截断可能对你的程序造成问题，你可以向 `zip` 传递一个新的关键字参数 `strict` ——这是自 Python 3.10 新增的功能——这将导致返回的生成器在任何输入在其它输入之前耗尽时抛出异常。

```
for name, count in zip(names, counts, strict=True):  # Changed
    print(name)
>>>
Cecilia
Lise
Marie
Traceback ...
ValueError: zip() argument 2 is shorter than argu
```

Alternatively, you can solve this truncation problem by using the `zip_longest` function from the `itertools` built-in module to fill in missing items with a default value (see Item 24: “Consider itertools for Working with Iterators and Generators”).

或者，你可以使用 `itertools` 标准库模块中的 `zip_longest` 函数来解决此截断问题，它可以通过默认值填充缺失的项（参见条目 24）。

**Things to Remember**

- The `zip` built-in function can be used to iterate over multiple iterators in parallel.
- `zip` creates a lazy generator that produces tuples; it can be used on infinitely long inputs.
- `zip` truncates its output silently to the shortest iterator if you supply it with iterators of different lengths.
- Pass the `strict` keyword argument to `zip` if you want to ensure that silent truncation is not possible and mismatched iterator lengths should result in a runtime error.

**注意事项**
- `zip` 内建函数可用于并行遍历多个迭代器。
- `zip` 创建一个惰性生成器，产生元组；它可以应用于无限长的输入。
- 如果提供给它的迭代器长度不同，`zip` 会默默地将其输出截断至最短的迭代器。
- 如果你想确保不会发生静默截断，且不匹配的迭代器长度应该导致运行时错误，则可以向 `zip` 传递 `strict` 关键字参数。